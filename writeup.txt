

TODO: PROBLEM AND MOTIVATION


DEFINITIONS

Consider a weighted, directed graph G = (V,E) embedded in a space C via the mapping psi : V -> C, with the edge weight function w : E -> R. Let d : C x C -> R be the distance metric used in C. Let d_sp : V x V -> R be defined as distance in G in the usual sense, i.e., d_sp(u,v) is the length of the shortest path from u to v. Note that d_sp is not a metric because G is directed. We would like to extend this definition to virtual vertices along the edges as well. For an edge e=(u,v) in E and t in (0,1), we imagine the virtual vertex e(t) to be a hypothetical point along e, such that, were the edge (u,e(t)) to exist, w(u,e(t)) = t*w(e). For convenience, we additionally use the notation e(0)=u, e(1)=v. Now let
    S = { e(t) | e in E, t in [0,1] }
be the set of all vertices and virtual vertices. We define an extended graph distance function, d_g : S x S -> R, as
    d_g(e1(t),e2(s)) = (1-t)*w(e1) + d_sp(v,w) + s*w(e2)
for t,s in [0,1], e1=(u,v), e2=(w,z) in E. We also define an extended mapping psi_hat : S -> C as
    psi_hat(e(t)) = psi(u) + t*psi(v)
for t in [0,1], e=(u,v) in E. In an abuse of notation, by psi_hat(U) for U c= S we mean { psi_hat(u) | u in U }. Now we may define a second distance function on S with respect to C, d_c : S x S -> R, as
    d_c(s1,s2) = d(psi_hat(s1),psi_hat(s2)).
We refer to d_g as graph distance and d_c as C-space distance. For a path p, length_g(p) indicates the sum of the edge weights comprising p, while length_c(p) indicates the sum of the C-space length of each edge. In some applications, the edge weights are set so that length_g(p) = length_c(p), but this need not be true.

For a set of paths, P, we define the diversity of P with respect to a path distance metric d_p as
    min(d_p(p1,p2), over all p1,p2 in P && p1!=p2).
In this paper, we will consider two path distance metrics: weighted Levenshtein edit distance, and discrete Frechet distance evaluated at the vertices. ... more detail about these metrics ... For brevity, we refer to these two metrics as Levenshtein distance and Frechet distance, respectively, and the corresponding diversity measures as Levenshtein diversity and Frechet diversity.

The mean path distance in P with respect to a path distance metric d_p is defined as
    (1/|P|)*sum(min(d_p(p1,p2), over all p2 in P && p1!=p2), over all p1 in P).
Similarly we will use the terminology mean Levenshtein distance and mean Frechet distance to refer to the mean path distance with respect to Levenshtein distance and Frechet distance respectively.

TODO: Fill in defintions of Levenshtein and Frechet.


ALGORITHMS

A. Sampling from a Path

An important part of our algorithm is to choose a random location along a path at which to center a ball. We cannot merely select a vertex uniformly from the path's edge endpoints because they are not guaranteed to be distributed uniformly along the path. Morever, we are able to measure distance not just between actual vertices, but also the virtual vertices. Thus we can center the ball anywhere along the path.

Suppose a sequence of edges ee = {e1,e2,...} defines a path through G. Let p = { e_i(t) | e_i in ee, t in [0,1] }. We would like to sample a point from p with probability corresponding to the edge weights. That is, the probability of sampling a point along e_i is proportional to the fraction of the total path length that e_i accounts for. The process is straightforward: Select the edge e_i with probability
w(e_i)/sum(w(e_j), for e_j in ee),
and sample t uniformly from [0,1].

In applications where an edge's weight is C-space distance between its endpoints, when sampled points are mapped into C-space by psi_hat, they will be uniformly distributed along psi_hat(p) according to C-space distance. If this C-space uniformity is desirable in an application that sets its edge weights differently, it is not difficult to alter the sampling method to use a d_c(u,v)/length_c(p) as the probability of selecting edge e=(u,v) to accomplish this.

B. Graph Modification

Since we want short paths which satisfy the same query from vertex s to vertex g, but which are different from one another, we develop a method to modify the graph, G=(V,E), on which the query is performed to create a new graph G'=(V,E') c G such that the shortest path, p', from s to g in G' is different than the shortest path, p, from s to g in G. Then, both p and p' are valid paths from s to g in G. Furthermore, though p' is not the shortest in G, it is the shortest subject to a constraint, namely that it not include the edges in E\E'.

To create G', we use the sampling method detailed above to sample a point c in p. For some distance function delta : S x S -> R, and some radius rho > 0, we then let
E' = { e | e in E, delta(c,e(t)) >= rho forall t in [0,1] }.
That is, E' is the subset of E containing only the edges which are entirely outside of the open ball of radius rho centered at c, with respect to the distance function delta. In this paper we explore the possibilities of delta = d_g and delta = d_c. Remember that d_g is only symmetric if G is effectively undirected. For the sake of scalability, rather than use a constant rho which may be difficult to select, we will use the function rho(r) = r*length(p) for a constant r in (0,1]. If delta = d_g, it is appropriate to use length(p) = length_g(p); if delta = d_c, to use length(p) = length_c(p) so that the value of rho is comparable. We may restrict r to (0,1/2] if delta is symmetric. Intuitively, the larger the value of r, the farther p', the shortest path from s to g in G'=(V,E'), must deviate from p because a larger collection of edges in and near p are removed. It is possible that no path from s to g exists in G', in which case a shortest path query will return an empty path.

C. Random Avoidance

We present an algorithm to heuristically search for a collection of paths all satisfying the same query in a graph, but which seeks to improve the robustness of the path set against failures in the graph. It does so by exploring diverse regions of the space while still favoring shorter paths. A shortest path search is performed on variants of the original graph designed to encourage deviation from known paths. The psuedocode is given in ... algorithm ....

The process begins by finding the shortest path through the unmodified graph, G, from the start to the goal vertices. This path is added to the result set, and the path together with G are added to a queue of reference solutions. We enter a loop that repeatedly removes the next reference path and graph from the queue as p and G. We use them in the graph modification method described above b times independently to produce b new path-graph pairs, (p1,G1),...,(p_b,G_b) for a constant integer b called the branching factor. Empty paths, which indicate failure of the shortest path query, are thrown out. Each of the remaining paths is considered for addition to the result set subject to some filtering criteria. This filtration is application specific. It may trivially accept any path, or it may reject a path that is too close to a previously accepted path, or it may reject a path that is too long, etc. Regardless of whether it is accepted, the path-graph pair is added to the reference queue. The loop repeats until the reference queue is empty or the result set is large enough, at which time the set is returned.

D. Our Implementation

-uses A*, special edge weight map to remove need to build entirely new graphs, etc.

EVALUATION

We measure the performance of the algorithm in three ways: 1) diversity with respect to the ball radius, 2) diversity with respect to graph density, and 3) execution speed with respect to diversity. In the first measure, we will explore two different flavors of diversity, Levenshtein and Frechet, and two variants of our algorithm, one using graph distance and the other using C-space distance. We will select the diversity that more faithfully captures the idea of diversity and use it in the second and third performance measures to compare our algorithm to Eppstein's k shortest paths algorithm. Our algorithm can filter paths according to some criteria before adding them to the result set. During our testing, this filtration trivially accepts all paths, except in the speed test where we make it filter for a minimum diversity requirement.

In all three experiments, the graph is generated by the SPARS2 algorithm on a 3D environment. The space is SE(3), with a distance metric that sums the Euclidean distance between the R^3 components and the arc-length along S^3 between the quaternion components. The parameters for SPARS2 which yielded each graph are given in ... table ... In each of the graphs, for every edge (u,v) there also exists an edge (v,u) because the motion it represents is valid both forward and backward. Also we set w((u,v)) = d(psi(u),psi(v)) so that graph distance and C-space distance perform comparable measurements. We always request a path set of 10 paths.

We designed our algorithm to deviate from known paths by avoiding balls of radius r*l, where l is the shortest path length and r is a constant factor. We have a choice of what distance function to use when we define balls of radius r*l. The two fundamental options we defined earlier are graph distance, d_g, and C-space distance, d_c. We want to discover whether one measure lends itself to better results than the other.

1) Our first performance measure is to compute the diversity of the path sets for varying values of the radius factor, r. We use the "grid" environment, a 5x5 array of blocks. While varying the radius factor, we will be able to see how the algorithm's behavior changes in response to this parameter by measuring both Levenshtein and Frechet diversity and what fraction of the number of paths requested was actually returned. We will also use Eppstein's k shortest paths with filtering to construct a path set with the same Levenshtein diversity and a set with the same Frechet diversity as the set returned by our algorithm for a particular radius factor. By visually examining these path sets to count homotopy classes, we will be able to compare how faithfully each diversity measure captures the intuition of diversity.

2) In this experiment we use SPARS2 on the "cubicles" environment to generate three different graphs of varying density. ... details of SPARS2 parameters ... We run our algorithm and Eppstein's k shortest paths to compare the diversity and mean path distance of the result sets.

3) Finally, we compare the relative speed of our algorithm and Eppstein's k shortest paths when we apply a constraint to filter the paths to achieve a minimum diversity. We use the same "grid" environment used before and measure the execution time of both algorithms for a range of minimum diversity requirements on a ... computer specs ... machine.

RESULTS

... plot ... shows the parameter sweep of the radius factor for the four different combinations of Levenshtein or Frechet diversity and graph distance or C-space distance. Observe that the diversity in all four cases responds well to an increase in the radius factor. When the algorithm avoids larger regions, the returned paths are naturally farther apart. However, we expect using larger radii risks covering too much of the graph too quickly so that fewer paths than requested can be returned; we see a corresponding increase in the failure rate on the plot for higher values of the radius factor. Note that the graph distance variant consistently requires a larger radius to achieve the same diversity as the C-space variant regardless of diversity measure; this too is expected because in this experiment, d_c(s1,s2) <= d_g(s1,s2) due to our edge weights and the triangle inequality.

... table ... gives statistics about the three graphs based on the "cubicles" environment. Each one is more dense than the last, having more nodes embedded in the same area, but the average degree remains approximately the same. We choose a fixed radius factor for each graph to be the highest value which still yields an average of 8 out of the 10 paths requested. Looking at the bars for Eppstein's algorithm in ... plot ... we see very predictable behavior: the k shortest paths in a denser graph are much more similar to each other than those in a sparser graph, so diversity and mean path distance decrease with an increase in density. Compare this to our algorithm which does not exhibit the same consistent decrease in diversity. In fact, the values are higher for the second sparsest graph than for the sparsest graph. We note that the diversity, which is the minimum distance among the paths, is near to the mean distance for the k shortest paths, but much lower than the mean distance for the paths returned by our algorithm. This suggests that the paths from our algorithm are typically much farther apart than the nearest of them. We also observe that as the density of the graph increases, the standard deviation over all the trials tightens. Thus, our algorithm performs more consistently with denser graphs. Finally, regardless of the density, our algorithm significantly outperforms the k shortest paths.

Now we compare the execution time of our algorithm with that of Eppstein's. On the problem of k shortest paths, Eppstein's algorithm executes extremely quickly, but it produces poor results if we are looking for a diverse path set. We wonder how fast Eppstein's algorithm performs if we modify it to throw out all paths which are too close to the paths already found. That is, for some diversity threshold, we greedily only keep a path if it would not decrease the diversity below this threshold. Returning to the "grid" environment, we fix the radius factor at 0.1, to yield a moderate diversity naturally, but one which is still significantly higher than that of the k shortest paths, and, most importantly for this comparison, to successfully yield most of the 10 paths we request even with a strict diversity requirement imposed. Shown in ... plot ... are the execution times for our algorithm and Eppstein's, both with filtering implemented to meet a minimum diversity requirement. We find that there is an exponential increase in the time required for Eppstein's algorithm to yield the requisite paths, which becomes unmangeable for even modest diversity requirements. Our algorithm, on the other hand only exhibits a small increase in execution time and not until much higher diversities, coinciding with a decrease in the number of paths successfully found by our algorithm.

TODO: Make node count differences between cubicles graphs more consistent.


TODO: CONCLUSION AND FUTURE WORK


(this snippet is probably useful somewhere) [[
If the edge weights correspond to the distance between the endpoints, i.e. w((u,v)) = d(psi(u),psi(v)), and if the graph is effectively undirected, as is the case for this experiment and for many applications, graph distance and C-space distance are attempting to capture the same information, but graph distance is forced to follow topology of the graph. In other applications where there is not this correspondence between the two measures, there may be applicaiton-specific reasons to choose one over the other.
]]
